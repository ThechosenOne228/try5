<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Share My Fit</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX/TypeScript -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.5s ease;
        }
        #video-feed.fade-out {
            opacity: 0;
        }
        #app-root {
            position: relative;
            z-index: 2;
        }
        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
            max-width: 80%;
            text-align: center;
        }
        #debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            min-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .loading-progress {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 15px 0;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background: #3498db;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .loading-steps {
            text-align: left;
            margin-top: 15px;
            font-size: 14px;
        }
        .loading-step {
            margin: 8px 0;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }
        .loading-step.active {
            opacity: 1;
            color: #3498db;
        }
        .loading-step.completed {
            opacity: 0.7;
            color: #2ecc71;
        }
        .camera-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        .camera-switch:hover {
            background: rgba(0, 0, 0, 0.7);
        }
        .camera-switch:active {
            transform: scale(0.95);
        }
        .detection-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            border: 2px solid #fff;
        }
        .detection-label:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        .brand-logo {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        .camera-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .camera-transition.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="video-feed" autoplay playsinline></video>
    </div>
    <div id="app-root"></div>
    <div id="error-message" style="display: none;"></div>
    <div id="debug-info"></div>
    <div id="camera-transition" class="camera-transition"></div>

    <!-- App Scripts -->
    <script type="text/babel">
        // Brand logos mapping
        const brandLogos = {
            // Sportswear
            'nike': 'https://upload.wikimedia.org/wikipedia/commons/a/a6/Logo_NIKE.svg',
            'adidas': 'https://upload.wikimedia.org/wikipedia/commons/2/20/Adidas_Logo.svg',
            'puma': 'https://upload.wikimedia.org/wikipedia/commons/4/44/Puma_logo.svg',
            'reebok': 'https://upload.wikimedia.org/wikipedia/commons/3/31/Reebok_2019_logo.svg',
            'under armour': 'https://upload.wikimedia.org/wikipedia/commons/7/7c/Under_Armour_logo.svg',
            'new balance': 'https://upload.wikimedia.org/wikipedia/commons/1/1d/New_Balance_logo.svg',
            'converse': 'https://upload.wikimedia.org/wikipedia/commons/3/3b/Converse_logo.svg',
            'vans': 'https://upload.wikimedia.org/wikipedia/commons/3/36/Vans-logo.svg',
            'jordan': 'https://upload.wikimedia.org/wikipedia/commons/a/a6/Logo_NIKE.svg',
            'asics': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Asics_logo.svg',
            'fila': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Fila_logo.svg',
            'mizuno': 'https://upload.wikimedia.org/wikipedia/commons/9/9c/Mizuno_logo.svg',
            'brooks': 'https://upload.wikimedia.org/wikipedia/commons/8/8a/Brooks_logo.svg',
            'saucony': 'https://upload.wikimedia.org/wikipedia/commons/7/7c/Saucony_logo.svg',
            'skechers': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Skechers_logo.svg',
            'lululemon': 'https://upload.wikimedia.org/wikipedia/commons/3/3c/Lululemon_logo.svg',
            'athleta': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Athleta_logo.svg',
            'gymshark': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Gymshark_logo.svg',
            'alphalete': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Alphalete_logo.svg',
            'nobull': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/NoBull_logo.svg',

            // Luxury
            'gucci': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Gucci_logo.svg',
            'louis vuitton': 'https://upload.wikimedia.org/wikipedia/commons/9/9f/Louis_Vuitton_logo.svg',
            'prada': 'https://upload.wikimedia.org/wikipedia/commons/3/3e/Prada_logo.svg',
            'versace': 'https://upload.wikimedia.org/wikipedia/commons/8/89/Versace_logo.svg',
            'dior': 'https://upload.wikimedia.org/wikipedia/commons/7/7f/Christian_Dior_logo.svg',
            'chanel': 'https://upload.wikimedia.org/wikipedia/commons/7/7a/Chanel_logo.svg',
            'hermes': 'https://upload.wikimedia.org/wikipedia/commons/4/4c/Herm%C3%A8s_logo.svg',
            'burberry': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Burberry_logo.svg',
            'fendi': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Fendi_logo.svg',
            'balenciaga': 'https://upload.wikimedia.org/wikipedia/commons/4/4b/Balenciaga_logo.svg',
            'givenchy': 'https://upload.wikimedia.org/wikipedia/commons/2/2f/Givenchy_logo.svg',
            'yves saint laurent': 'https://upload.wikimedia.org/wikipedia/commons/3/3c/Yves_Saint_Laurent_logo.svg',
            'bottega veneta': 'https://upload.wikimedia.org/wikipedia/commons/5/5a/Bottega_Veneta_logo.svg',
            'valentino': 'https://upload.wikimedia.org/wikipedia/commons/9/9a/Valentino_logo.svg',
            'dolce & gabbana': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Dolce_%26_Gabbana_logo.svg',
            'alexander mcqueen': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Alexander_McQueen_logo.svg',
            'balmain': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Balmain_logo.svg',
            'celine': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Celine_logo.svg',
            'loewe': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Loewe_logo.svg',
            'marni': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Marni_logo.svg',

            // Streetwear & Fashion
            'supreme': 'https://upload.wikimedia.org/wikipedia/commons/2/28/Supreme_logo.svg',
            'off-white': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Off-White_logo.svg',
            'palace': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Palace_Skateboards_logo.svg',
            'stussy': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Stussy_logo.svg',
            'bape': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/BAPE_logo.svg',
            'kith': 'https://upload.wikimedia.org/wikipedia/commons/4/4c/Kith_logo.svg',
            'fear of god': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Fear_of_God_logo.svg',
            'yeezy': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Yeezy_logo.svg',
            'stone island': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Stone_Island_logo.svg',
            'moncler': 'https://upload.wikimedia.org/wikipedia/commons/4/4c/Moncler_logo.svg',
            'acne studios': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Acne_Studios_logo.svg',
            'alyx': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Alyx_logo.svg',
            'ambush': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Ambush_logo.svg',
            'heron preston': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Heron_Preston_logo.svg',
            'martine rose': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Martine_Rose_logo.svg',

            // Fast Fashion
            'zara': 'https://upload.wikimedia.org/wikipedia/commons/5/53/Zara_logo.svg',
            'h&m': 'https://upload.wikimedia.org/wikipedia/commons/5/53/H%26M-Logo.svg',
            'uniqlo': 'https://upload.wikimedia.org/wikipedia/commons/9/92/UNIQLO_logo.svg',
            'forever 21': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Forever_21_logo.svg',
            'topshop': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Topshop_logo.svg',
            'asos': 'https://upload.wikimedia.org/wikipedia/commons/0/0c/ASOS_logo.svg',
            'boohoo': 'https://upload.wikimedia.org/wikipedia/commons/4/4c/Boohoo_logo.svg',
            'missguided': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Missguided_logo.svg',
            'pretty little thing': 'https://upload.wikimedia.org/wikipedia/commons/5/5a/PrettyLittleThing_logo.svg',
            'nasty gal': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Nasty_Gal_logo.svg',
            'fashion nova': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Fashion_Nova_logo.svg',
            'revolve': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Revolve_logo.svg',
            'nordstrom': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Nordstrom_logo.svg',
            'urban outfitters': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Urban_Outfitters_logo.svg',
            'anthropologie': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Anthropologie_logo.svg',

            // Denim & Casual
            'levi\'s': 'https://upload.wikimedia.org/wikipedia/commons/2/21/Levi%27s_logo.svg',
            'gap': 'https://upload.wikimedia.org/wikipedia/commons/7/7a/Gap_logo.svg',
            'calvin klein': 'https://upload.wikimedia.org/wikipedia/commons/5/5c/Calvin_Klein_logo.svg',
            'tommy hilfiger': 'https://upload.wikimedia.org/wikipedia/commons/5/5c/Tommy_Hilfiger_Logo.svg',
            'ralph lauren': 'https://upload.wikimedia.org/wikipedia/commons/d/d6/Ralph_Lauren_logo.svg',
            'wrangler': 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Wrangler_logo.svg',
            'lee': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Lee_logo.svg',
            'diesel': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Diesel_logo.svg',
            'guess': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Guess_logo.svg',
            'hollister': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Hollister_logo.svg',
            'abercrombie': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Abercrombie_logo.svg',
            'american eagle': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/American_Eagle_logo.svg',
            'banana republic': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Banana_Republic_logo.svg',
            'j.crew': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/J.Crew_logo.svg',
            'madewell': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Madewell_logo.svg',

            // Accessories
            'ray-ban': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Ray-Ban_logo.svg',
            'oakley': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Oakley_logo.svg',
            'swatch': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Swatch_logo.svg',
            'fossil': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Fossil_logo.svg',
            'michael kors': 'https://upload.wikimedia.org/wikipedia/commons/5/5c/Michael_Kors_logo.svg',
            'kate spade': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Kate_Spade_logo.svg',
            'coach': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Coach_logo.svg',
            'tory burch': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Tory_Burch_logo.svg',
            'longchamp': 'https://upload.wikimedia.org/wikipedia/commons/5/5c/Longchamp_logo.svg',
            'furla': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Furla_logo.svg',
            'marc jacobs': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Marc_Jacobs_logo.svg',
            'rebecca minkoff': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Rebecca_Minkoff_logo.svg',
            'dooney & bourke': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Dooney_%26_Bourke_logo.svg',
            'tumi': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Tumi_logo.svg',
            'samsonite': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Samsonite_logo.svg',

            // Watches
            'rolex': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Rolex_logo.svg',
            'omega': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Omega_logo.svg',
            'cartier': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Cartier_logo.svg',
            'tag heuer': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Tag_Heuer_logo.svg',
            'breitling': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Breitling_logo.svg',
            'iwc': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/IWC_logo.svg',
            'jaeger-lecoultre': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Jaeger-LeCoultre_logo.svg',
            'panerai': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Panerai_logo.svg',
            'hublot': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Hublot_logo.svg',
            'audemars piguet': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Audemars_Piguet_logo.svg',
            'patek philippe': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Patek_Philippe_logo.svg',
            'vacheron constantin': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Vacheron_Constantin_logo.svg',
            'breguet': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Breguet_logo.svg',
            'zenith': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Zenith_logo.svg',
            'tissot': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Tissot_logo.svg',

            // Jewelry
            'tiffany & co': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Tiffany_%26_Co_logo.svg',
            'cartier': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Cartier_logo.svg',
            'bulgari': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Bulgari_logo.svg',
            'van cleef & arpels': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Van_Cleef_%26_Arpels_logo.svg',
            'david yurman': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/David_Yurman_logo.svg',
            'pandora': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Pandora_logo.svg',
            'swarovski': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Swarovski_logo.svg',
            'kendra scott': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Kendra_Scott_logo.svg',
            'gorjana': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Gorjana_logo.svg',
            'alex and ani': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Alex_and_Ani_logo.svg',
            'james avery': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/James_Avery_logo.svg',
            'john hardy': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/John_Hardy_logo.svg',
            'monica vinader': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Monica_Vinader_logo.svg',
            'mejuri': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Mejuri_logo.svg',
            'catbird': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Catbird_logo.svg',

            // Footwear
            'dr. martens': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Dr._Martens_logo.svg',
            'timberland': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Timberland_logo.svg',
            'clarks': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Clarks_logo.svg',
            'ugg': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/UGG_logo.svg',
            'birkenstock': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Birkenstock_logo.svg',
            'crocs': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Crocs_logo.svg',
            'teva': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Teva_logo.svg',
            'merrell': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Merrell_logo.svg',
            'keen': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/KEEN_logo.svg',
            'salomon': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Salomon_logo.svg',
            'hoka': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Hoka_logo.svg',
            'on running': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/On_Running_logo.svg',
            'allbirds': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Allbirds_logo.svg',
            'veja': 'https://upload.wikimedia.org/wikipedia/commons/7/7d/Veja_logo.svg',
            'common projects': 'https://upload.wikimedia.org/wikipedia/commons/2/2a/Common_Projects_logo.svg'
        };

        // Function to detect brand from class name
        function detectBrand(className) {
            const lowerClassName = className.toLowerCase();
            for (const [brand, _] of Object.entries(brandLogos)) {
                if (lowerClassName.includes(brand)) {
                    return brand;
                }
            }
            return null;
        }

        // Debug logging function
        function debugLog(message) {
            console.log(message);
            const debugInfo = document.getElementById('debug-info');
            debugInfo.textContent = message;
        }

        // Error handling function
        function showError(message) {
            console.error(message);
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Check if required libraries are loaded
        function checkDependencies() {
            const dependencies = {
                'React': typeof React !== 'undefined',
                'ReactDOM': typeof ReactDOM !== 'undefined',
                'TensorFlow.js': typeof tf !== 'undefined',
                'COCO-SSD': typeof cocoSsd !== 'undefined'
            };

            const missing = Object.entries(dependencies)
                .filter(([_, loaded]) => !loaded)
                .map(([name]) => name);

            if (missing.length > 0) {
                throw new Error(`Missing dependencies: ${missing.join(', ')}`);
            }

            debugLog('All dependencies loaded successfully');
        }

        // Initialize webcam
        async function initWebcam(facingMode = 'user') {
            try {
                debugLog(`Requesting camera access (${facingMode})...`);
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: facingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    } 
                });
                const videoElement = document.getElementById('video-feed');
                
                // Stop any existing stream
                if (videoElement.srcObject) {
                    videoElement.srcObject.getTracks().forEach(track => track.stop());
                }
                
                videoElement.srcObject = stream;
                
                debugLog('Camera access granted');
                
                // Wait for video to be ready
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        debugLog('Video stream ready');
                        resolve(videoElement);
                    };
                });
            } catch (err) {
                const errorMsg = 'Error accessing webcam: ' + err.message;
                debugLog(errorMsg);
                showError(errorMsg);
                throw err;
            }
        }

        // App Component
        const App = ({ initialVideoRef }) => {
            const [detections, setDetections] = React.useState([]);
            const [isModelLoading, setIsModelLoading] = React.useState(true);
            const [loadingProgress, setLoadingProgress] = React.useState(0);
            const [loadingStep, setLoadingStep] = React.useState('Initializing...');
            const [loadingSteps, setLoadingSteps] = React.useState([
                { id: 'init', text: 'Initializing application...', status: 'active' },
                { id: 'tf', text: 'Loading TensorFlow.js...', status: 'pending' },
                { id: 'model', text: 'Loading AI model...', status: 'pending' },
                { id: 'camera', text: 'Setting up camera...', status: 'pending' },
                { id: 'ready', text: 'Ready to detect!', status: 'pending' }
            ]);
            const [showToast, setShowToast] = React.useState(false);
            const [error, setError] = React.useState(null);
            const [isFrontCamera, setIsFrontCamera] = React.useState(true);
            const [videoRef, setVideoRef] = React.useState(initialVideoRef);
            const [isTransitioning, setIsTransitioning] = React.useState(false);
            const [fps, setFps] = React.useState(0);
            const modelRef = React.useRef(null);
            const frameCountRef = React.useRef(0);
            const lastTimeRef = React.useRef(performance.now());
            const detectionCanvasRef = React.useRef(null);
            const detectionContextRef = React.useRef(null);
            const isDetectingRef = React.useRef(false);
            const previousDetectionsRef = React.useRef([]);
            const objectTracksRef = React.useRef(new Map());
            const overlayCanvasRef = React.useRef(null);
            const overlayContextRef = React.useRef(null);

            // Target object classes with their minimum confidence thresholds
            const TARGET_CLASSES = {
                'person': 0.6,
                'car': 0.7,
                'shoe': 0.65,
                'cell phone': 0.7,
                'laptop': 0.7
            };

            // Calculate IoU (Intersection over Union) between two bounding boxes
            const calculateIoU = (box1, box2) => {
                const [x1, y1, w1, h1] = box1;
                const [x2, y2, w2, h2] = box2;
                
                const intersectionX = Math.max(x1, x2);
                const intersectionY = Math.max(y1, y2);
                const intersectionWidth = Math.min(x1 + w1, x2 + w2) - intersectionX;
                const intersectionHeight = Math.min(y1 + h1, y2 + h2) - intersectionY;
                
                if (intersectionWidth <= 0 || intersectionHeight <= 0) return 0;
                
                const intersectionArea = intersectionWidth * intersectionHeight;
                const box1Area = w1 * h1;
                const box2Area = w2 * h2;
                
                return intersectionArea / (box1Area + box2Area - intersectionArea);
            };

            // Smooth bounding box coordinates
            const smoothBoundingBox = (current, previous, alpha = 0.3) => {
                if (!previous) return current;
                return current.map((coord, i) => 
                    previous[i] + alpha * (coord - previous[i])
                );
            };

            // Mock product metadata with more details
            const mockProductData = {
                'person': {
                    title: 'Person',
                    description: 'Human detected',
                    color: '#FF0000',
                    brand: 'Human'
                },
                'car': {
                    title: 'Vehicle',
                    description: 'Automobile detected',
                    color: '#0000FF',
                    brand: 'Vehicle'
                },
                'shoe': {
                    title: 'Nike Air Max 90',
                    description: 'Classic sneaker with Air cushioning',
                    price: '$129.99',
                    color: '#00FF00',
                    brand: 'Nike'
                },
                'cell phone': {
                    title: 'iPhone 14 Pro',
                    description: 'Latest smartphone with A16 chip',
                    price: '$999.99',
                    color: '#FF00FF',
                    brand: 'Apple'
                },
                'laptop': {
                    title: 'MacBook Pro',
                    description: 'Professional laptop with M2 chip',
                    price: '$1999.99',
                    color: '#FFFF00',
                    brand: 'Apple'
                }
            };

            // Object expiry settings
            const OBJECT_EXPIRY_FRAMES = 30; // ~1 second at 30fps
            const objectLastSeenRef = React.useRef(new Map());

            // Track objects with expiry
            const trackObjects = React.useCallback((predictions) => {
                const currentTracks = new Map(objectTracksRef.current);
                const currentTime = Date.now();

                // Update last seen time for all current detections
                predictions.forEach(pred => {
                    const key = `${pred.class}-${pred.bbox.join(',')}`;
                    objectLastSeenRef.current.set(key, currentTime);
                });

                // Remove expired objects
                for (const [key, lastSeen] of objectLastSeenRef.current) {
                    if (currentTime - lastSeen > OBJECT_EXPIRY_FRAMES * (1000 / 30)) {
                        objectLastSeenRef.current.delete(key);
                        currentTracks.delete(key);
                    }
                }

                // Update tracks with new predictions
                predictions.forEach(pred => {
                    const key = `${pred.class}-${pred.bbox.join(',')}`;
                    const existingTrack = currentTracks.get(key);
                    
                    if (existingTrack) {
                        // Update existing track
                        currentTracks.set(key, {
                            ...existingTrack,
                            lastBbox: pred.bbox,
                            confidence: pred.score,
                            age: existingTrack.age + 1
                        });
                    } else {
                        // Create new track
                        currentTracks.set(key, {
                            id: key,
                            class: pred.class,
                            lastBbox: pred.bbox,
                            confidence: pred.score,
                            age: 0
                        });
                    }
                });

                objectTracksRef.current = currentTracks;
                return Array.from(currentTracks.values());
            }, []);

            // Draw detection overlays with enhanced labels
            const drawOverlays = React.useCallback((detections) => {
                if (!overlayContextRef.current || !detections) return;

                const ctx = overlayContextRef.current;
                const canvas = overlayCanvasRef.current;
                
                // Ensure canvas dimensions match window
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Clear previous frame
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                detections.forEach(detection => {
                    if (!detection.lastBbox || detection.lastBbox.length !== 4) return;
                    
                    const [x, y, width, height] = detection.lastBbox;
                    const metadata = mockProductData[detection.class] || {
                        title: detection.class,
                        description: 'Object detected',
                        color: '#FFFFFF',
                        brand: detection.class
                    };

                    // Ensure coordinates are within canvas bounds
                    const safeX = Math.max(0, Math.min(x, canvas.width));
                    const safeY = Math.max(0, Math.min(y, canvas.height));
                    const safeWidth = Math.min(width, canvas.width - safeX);
                    const safeHeight = Math.min(height, canvas.height - safeY);

                    // Draw bounding box with fade effect based on age
                    const alpha = Math.min(1, 0.3 + (detection.age / 10));
                    ctx.strokeStyle = `${metadata.color}${Math.round(alpha * 255).toString(16).padStart(2, '0')}`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(safeX, safeY, safeWidth, safeHeight);

                    // Calculate label position (prefer top-left, fallback to bottom)
                    const labelText = [
                        `${metadata.brand}`,
                        `${metadata.title}`,
                        metadata.price ? `${metadata.price}` : '',
                        `${metadata.description}`
                    ].filter(Boolean);

                    ctx.font = '14px Arial';
                    const textMetrics = ctx.measureText(labelText[0]);
                    const labelWidth = Math.max(...labelText.map(text => ctx.measureText(text).width)) + 20;
                    const labelHeight = labelText.length * 20 + 10;

                    // Determine if label should go on top or bottom
                    const hasSpaceOnTop = safeY > labelHeight;
                    const labelY = hasSpaceOnTop ? safeY - labelHeight : safeY + safeHeight;
                    const labelX = Math.min(safeX, canvas.width - labelWidth);

                    // Draw label background with fade effect
                    ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                    ctx.fillRect(labelX, labelY, labelWidth, labelHeight);

                    // Draw label text
                    ctx.fillStyle = '#FFFFFF';
                    labelText.forEach((text, index) => {
                        ctx.fillText(text, labelX + 10, labelY + 20 + (index * 20));
                    });
                });
            }, []);

            // Optimized detection loop
            const detectObjects = React.useCallback(async () => {
                if (!modelRef.current || !videoRef || !detectionContextRef.current || isTransitioning || isDetectingRef.current) {
                    requestAnimationFrame(detectObjects);
                    return;
                }

                try {
                    isDetectingRef.current = true;

                    // Scale down video frame for detection
                    const ctx = detectionContextRef.current;
                    const canvas = detectionCanvasRef.current;
                    
                    if (!ctx || !canvas || !videoRef.videoWidth || !videoRef.videoHeight) {
                        requestAnimationFrame(detectObjects);
                        return;
                    }
                    
                    // Clear previous frame
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Calculate aspect ratio to maintain video proportions
                    const videoAspectRatio = videoRef.videoWidth / videoRef.videoHeight;
                    const canvasAspectRatio = canvas.width / canvas.height;
                    
                    let drawWidth = canvas.width;
                    let drawHeight = canvas.height;
                    let offsetX = 0;
                    let offsetY = 0;

                    if (videoAspectRatio > canvasAspectRatio) {
                        drawHeight = canvas.width / videoAspectRatio;
                        offsetY = (canvas.height - drawHeight) / 2;
                    } else {
                        drawWidth = canvas.height * videoAspectRatio;
                        offsetX = (canvas.width - drawWidth) / 2;
                    }

                    // Draw scaled frame
                    ctx.drawImage(
                        videoRef,
                        offsetX, offsetY,
                        drawWidth, drawHeight
                    );

                    // Run detection on scaled frame
                    const predictions = await modelRef.current.detect(canvas);

                    if (!predictions || !Array.isArray(predictions)) {
                        requestAnimationFrame(detectObjects);
                        return;
                    }

                    // Filter and process predictions
                    const filteredPredictions = predictions
                        .filter(pred => {
                            const minConfidence = TARGET_CLASSES[pred.class] || 0.5;
                            return pred.score >= minConfidence && pred.bbox && pred.bbox.length === 4;
                        })
                        .map(pred => {
                            // Scale predictions back to original video size
                            const scaleX = videoRef.videoWidth / canvas.width;
                            const scaleY = videoRef.videoHeight / canvas.height;
                            return {
                                ...pred,
                                bbox: [
                                    pred.bbox[0] * scaleX,
                                    pred.bbox[1] * scaleY,
                                    pred.bbox[2] * scaleX,
                                    pred.bbox[3] * scaleY
                                ]
                            };
                        });

                    // Track objects and update state
                    const trackedObjects = trackObjects(filteredPredictions);
                    setDetections(trackedObjects);
                    previousDetectionsRef.current = trackedObjects;

                    // Draw overlays
                    drawOverlays(trackedObjects);

                } catch (err) {
                    console.error('Detection error:', err);
                } finally {
                    isDetectingRef.current = false;
                    requestAnimationFrame(detectObjects);
                }
            }, [videoRef, isTransitioning, drawOverlays]);

            // Initialize canvases
            React.useEffect(() => {
                let animationFrameId;

                // Detection canvas
                const detectionCanvas = document.createElement('canvas');
                detectionCanvas.width = 640;
                detectionCanvas.height = 480;
                detectionCanvasRef.current = detectionCanvas;
                detectionContextRef.current = detectionCanvas.getContext('2d');

                // Overlay canvas
                const overlayCanvas = document.createElement('canvas');
                overlayCanvas.width = window.innerWidth;
                overlayCanvas.height = window.innerHeight;
                overlayCanvas.style.position = 'absolute';
                overlayCanvas.style.top = '0';
                overlayCanvas.style.left = '0';
                overlayCanvas.style.pointerEvents = 'none';
                overlayCanvas.style.zIndex = '1000';
                document.body.appendChild(overlayCanvas);
                overlayCanvasRef.current = overlayCanvas;
                overlayContextRef.current = overlayCanvas.getContext('2d');

                // Handle window resize
                const handleResize = () => {
                    if (overlayCanvasRef.current) {
                        overlayCanvasRef.current.width = window.innerWidth;
                        overlayCanvasRef.current.height = window.innerHeight;
                    }
                };
                window.addEventListener('resize', handleResize);

                // Start detection loop
                const startDetection = () => {
                    animationFrameId = requestAnimationFrame(detectObjects);
                };
                startDetection();

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (overlayCanvasRef.current) {
                        document.body.removeChild(overlayCanvasRef.current);
                    }
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                };
            }, [detectObjects]);

            // FPS counter
            React.useEffect(() => {
                const updateFPS = () => {
                    const now = performance.now();
                    const elapsed = now - lastTimeRef.current;
                    frameCountRef.current++;

                    if (elapsed >= 1000) {
                        setFps(Math.round((frameCountRef.current * 1000) / elapsed));
                        frameCountRef.current = 0;
                        lastTimeRef.current = now;
                    }
                    requestAnimationFrame(updateFPS);
                };
                requestAnimationFrame(updateFPS);
            }, []);

            // Update loading step
            const updateLoadingStep = (stepId, status) => {
                setLoadingSteps(prevSteps => 
                    prevSteps.map(step => 
                        step.id === stepId 
                            ? { ...step, status } 
                            : step
                    )
                );
            };

            // Load the COCO-SSD model
            React.useEffect(() => {
                const loadModel = async () => {
                    try {
                        // Initialize TensorFlow.js
                        setLoadingProgress(10);
                        setLoadingStep('Loading TensorFlow.js...');
                        updateLoadingStep('init', 'completed');
                        updateLoadingStep('tf', 'active');
                        
                        await tf.ready();
                        setLoadingProgress(30);
                        updateLoadingStep('tf', 'completed');
                        updateLoadingStep('model', 'active');
                        
                        // Load the COCO-SSD model
                        setLoadingStep('Loading AI model...');
                        const model = await cocoSsd.load({
                            base: 'lite_mobilenet_v2'
                        });
                        
                        setLoadingProgress(70);
                        updateLoadingStep('model', 'completed');
                        updateLoadingStep('camera', 'active');
                        
                        // Setup camera
                        setLoadingStep('Setting up camera...');
                        await new Promise(resolve => setTimeout(resolve, 500)); // Simulate camera setup
                        
                        setLoadingProgress(90);
                        updateLoadingStep('camera', 'completed');
                        updateLoadingStep('ready', 'active');
                        
                        // Final setup
                        await new Promise(resolve => setTimeout(resolve, 500));
                        setLoadingProgress(100);
                        setLoadingStep('Ready to detect!');
                        
                        modelRef.current = model;
                        setIsModelLoading(false);
                        
                        // Hide loading after a short delay
                        setTimeout(() => {
                            updateLoadingStep('ready', 'completed');
                        }, 1000);
                    } catch (err) {
                        const errorMsg = 'Failed to load the AI model: ' + err.message;
                        debugLog(errorMsg);
                        setError(errorMsg);
                    }
                };
                loadModel();
            }, []);

            const handleShare = () => {
                try {
                    const items = detections
                        .filter(det => ['person', 'backpack', 'handbag', 'suitcase', 'bottle', 'wine glass', 'cup', 'bowl', 'chair', 'couch', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'].includes(det.class))
                        .map(det => det.class);
                    
                    const text = `Today's Fit: ${items.join(', ')}`;
                    navigator.clipboard.writeText(text);
                    setShowToast(true);
                    setTimeout(() => setShowToast(false), 2000);
                } catch (err) {
                    const errorMsg = 'Share error: ' + err.message;
                    debugLog(errorMsg);
                    setError(errorMsg);
                }
            };

            // Handle camera switch
            const handleCameraSwitch = React.useCallback(async () => {
                if (isTransitioning) return;

                try {
                    setIsTransitioning(true);
                    setLoadingStep('Switching camera...');
                    setLoadingProgress(50);

                    // Stop all tracks
                    if (videoRef.srcObject) {
                        videoRef.srcObject.getTracks().forEach(track => track.stop());
                    }

                    // Clear detection state
                    setDetections([]);
                    objectTracksRef.current.clear();
                    objectLastSeenRef.current.clear();

                    // Switch camera
                    const newFacingMode = isFrontCamera ? 'environment' : 'user';
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: newFacingMode }
                    });

                    // Update video source
                    videoRef.srcObject = stream;
                    await videoRef.play();

                    // Update state
                    setIsFrontCamera(!isFrontCamera);
                    setLoadingProgress(100);
                    setLoadingStep('Camera switched successfully!');

                    // Reset loading state after a short delay
                    setTimeout(() => {
                        setIsTransitioning(false);
                        setLoadingStep('');
                        setLoadingProgress(0);
                    }, 1000);

                } catch (err) {
                    console.error('Camera switch error:', err);
                    setLoadingStep('Failed to switch camera. Please try again.');
                    setTimeout(() => {
                        setIsTransitioning(false);
                        setLoadingStep('');
                        setLoadingProgress(0);
                    }, 2000);
                }
            }, [isFrontCamera, isTransitioning, videoRef]);

            // Initialize webcam with proper error handling
            const initWebcam = React.useCallback(async () => {
                try {
                    setLoadingStep('Initializing camera...');
                    setLoadingProgress(20);

                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user' }
                    });

                    if (videoRef) {
                        videoRef.srcObject = stream;
                        await videoRef.play();
                        setLoadingProgress(40);
                        setLoadingStep('Camera initialized successfully!');
                    }

                } catch (err) {
                    console.error('Webcam initialization error:', err);
                    setLoadingStep('Failed to access camera. Please check permissions.');
                    throw err;
                }
            }, [videoRef]);

            if (error) {
                return React.createElement('div', { className: 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50' },
                    React.createElement('div', { className: 'bg-white p-6 rounded-lg shadow-xl max-w-md' },
                        React.createElement('h2', { className: 'text-xl font-bold text-red-600 mb-4' }, 'Error'),
                        React.createElement('p', { className: 'text-gray-700 mb-4' }, error),
                        React.createElement('button', {
                            onClick: () => window.location.reload(),
                            className: 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600'
                        }, 'Refresh Page')
                    )
                );
            }

            return React.createElement('div', { className: 'relative w-full h-screen' },
                // FPS Counter
                React.createElement('div', {
                    className: 'fixed top-4 left-4 bg-black bg-opacity-50 text-white px-2 py-1 rounded text-sm'
                }, `${fps} FPS`),
                // Camera Switch Button
                React.createElement('button', {
                    onClick: handleCameraSwitch,
                    className: 'camera-switch',
                    title: `Switch to ${isFrontCamera ? 'back' : 'front'} camera`,
                    disabled: isTransitioning
                }, 'ðŸ“·'),
                // Share Button
                React.createElement('button', {
                    onClick: handleShare,
                    className: 'fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-full shadow-lg transition-all duration-200'
                }, 'Share My Fit'),
                // Loading Indicator
                isModelLoading && React.createElement('div', { className: 'loading-container' },
                    React.createElement('div', { className: 'loading-spinner' }),
                    React.createElement('h3', { className: 'text-lg font-semibold mb-2' }, loadingStep),
                    React.createElement('div', { className: 'loading-progress' },
                        React.createElement('div', {
                            className: 'loading-progress-bar',
                            style: { width: `${loadingProgress}%` }
                        })
                    ),
                    React.createElement('div', { className: 'loading-steps' },
                        loadingSteps.map(step => 
                            React.createElement('div', {
                                key: step.id,
                                className: `loading-step ${step.status}`
                            }, step.text)
                        )
                    )
                ),
                // Toast Message
                showToast && React.createElement('div', {
                    className: 'fixed top-8 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded shadow-lg transition-all duration-200'
                }, 'Outfit copied to clipboard!')
            );
        };

        // Initialize app
        async function initApp() {
            try {
                debugLog('Initializing app...');
                checkDependencies();
                const videoElement = await initWebcam();
                debugLog('Creating React root...');
                const root = ReactDOM.createRoot(document.getElementById('app-root'));
                debugLog('Rendering app...');
                root.render(React.createElement(App, { initialVideoRef: videoElement }));
                debugLog('App initialized successfully');
            } catch (err) {
                const errorMsg = 'Failed to initialize app: ' + err.message;
                debugLog(errorMsg);
                showError(errorMsg);
            }
        }

        // Start the app
        initApp();
    </script>
</body>
</html> 